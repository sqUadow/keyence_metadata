<!DOCTYPE html>
<html>
<head>
    <title>TIFF Metadata Viewer</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        .metadata-table {
            border-collapse: collapse;
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
        }
        .metadata-table td, .metadata-table th {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .metadata-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        #drop-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            cursor: pointer;
        }
        #drop-area.highlight {
            border-color: #666;
            background-color: #eee;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TIFF Metadata Viewer</h1>
        <div id="drop-area">
            Drag and Drop TIFF file here or <label for="fileInput" style="cursor: pointer; text-decoration: underline;">click to select</label>
        </div>
        <input type="file" id="fileInput" accept=".tiff,.tif" style="display: none;">
        <div id="output"></div>
    </div>

    <script>
        async function loadPyodideAndFunctions() {
            let pyodide = await loadPyodide();
            // Install required packages (micropip is included with pyodide)
           // await pyodide.loadPackage("micropip");
           // await pyodide.runPythonAsync(`
           //     import micropip
           //     await micropip.install('some_package')  # Example: If you need other packages
           // `);

            // Define the Python functions (including necessary imports)
            await pyodide.runPythonAsync(`
import re

def parse_metadata(content):
    """Parses Keyence microscope metadata from a TIFF file."""
    match = re.search(r'<Data>(.*?)</Data>', content, re.DOTALL)
    if not match:
        return {}

    data_str = match.group(1)
    metadata = {}

    # --- Image Section ---
    image_match = re.search(r'<Image [^>]*>(.*?)</Image>', data_str, re.DOTALL)
    if image_match:
        image_data = image_match.group(1)
        metadata['Comment'] = _extract_value(image_data, 'Comment')
        metadata['OriginalImageSize_Width'] = _extract_value(image_data, 'OriginalImageSize', 'Width')
        metadata['OriginalImageSize_Height'] = _extract_value(image_data, 'OriginalImageSize', 'Height')
        metadata['SavingImageSize_Width'] = _extract_value(image_data, 'SavingImageSize', 'Width')
        metadata['SavingImageSize_Height'] = _extract_value(image_data, 'SavingImageSize', 'Height')
        metadata['DigitalZoom'] = _extract_value(image_data, 'DigitalZoom')
        metadata['Calibration'] = _extract_value(image_data, 'Calibration')
        metadata['Focus'] = _extract_value(image_data, 'Focus')
        metadata['PatchNumber'] = _extract_value(image_data, 'PatchNumber')


    # --- Lens Section ---
    lens_match = re.search(r'<Lens [^>]*>(.*?)</Lens>', data_str, re.DOTALL)
    if lens_match:
        lens_data = lens_match.group(1)
        metadata['LensName'] = _extract_value(lens_data, 'LensName')
        metadata['Magnification'] = _extract_value(lens_data, 'Magnification')
        metadata['NumericalAperture'] = _extract_value(lens_data, 'NumericalAperture')
        metadata['WorkingDistance'] = _extract_value(lens_data, 'WorkingDistance')
        metadata['LiquidImmersion'] = _extract_value(lens_data, 'LiquidImmersion')
        metadata['RevolverPosition'] = _extract_value(lens_data, 'RevolverPosition')

    # --- Shooting Section ---
    shooting_match = re.search(r'<Shooting [^>]*>(.*?)</Shooting>', data_str, re.DOTALL)
    if shooting_match:
        shooting_data = shooting_match.group(1)
        metadata['StageLocationX'] = _extract_value(shooting_data, 'StageLocationX')
        metadata['StageLocationY'] = _extract_value(shooting_data, 'StageLocationY')
        metadata['StageLocationZ'] = _extract_value(shooting_data, 'StageLocationZ')
        metadata['Channel'] = _extract_value(shooting_data, 'Channel')
        metadata['Observation'] = _extract_value(shooting_data, 'Observation')
        metadata['PseudoColor'] = _extract_value(shooting_data, 'PseudoColor', search_in='Parameter')
        metadata['Binning'] = _extract_value(shooting_data, 'Binnin', search_in='Parameter')
        metadata['ExposureTime_Numerator'] = _extract_value(shooting_data, 'ExposureTime', 'Numerator')
        metadata['ExposureTime_Denominator'] = _extract_value(shooting_data, 'ExposureTime', 'Denominator')
        metadata['PixelMode'] = _extract_value(shooting_data, 'PixelMode', search_in='Parameter')
        metadata['CameraGain'] = _extract_value(shooting_data, 'CameraGain', search_in='Parameter')
        metadata['CameraHardwareGain'] = _extract_value(shooting_data, 'CameraHardwareGain', search_in='Parameter')
    return metadata

def _extract_value(data_str, tag, subtag=None, search_in=None):
    """Helper function to extract values from the XML-like structure."""

    if search_in:
        # Search within a nested tag (e.g., Parameter)
        outer_match = re.search(rf'<{search_in} [^>]*>(.*?)</{search_in}>', data_str, re.DOTALL)
        if not outer_match:
            return None
        data_str = outer_match.group(1)

    if subtag:
        # Look for a specific subtag (e.g., Width within OriginalImageSize)
        pattern = rf'<{tag} [^>]*>.*?<{subtag} [^>]*>(.*?)</{subtag}>.*?</{tag}>'
    else:
        # Look for a simple tag
        pattern = rf'<{tag} [^>]*>(.*?)</{tag}>'

    match = re.search(pattern, data_str, re.DOTALL)
    return match.group(1) if match else None


def format_metadata_table(metadata):
    if not metadata:
        return "<p>No metadata found.</p>"

    html = "<table class='metadata-table'>"
    html += "<tr><th>Parameter</th><th>Value</th></tr>"
    for key, value in metadata.items():
        if value is not None:
            html += f"<tr><td>{key}</td><td>{value}</td></tr>"
    html += "</table>"
    return html
            `);

            return pyodide;
        }

        let pyodideReadyPromise = loadPyodideAndFunctions();

        async function processTiff(file) {
            let pyodide = await pyodideReadyPromise;

            const reader = new FileReader();
            reader.onload = async function(e) {
                const arrayBuffer = e.target.result;
                const uint8Array = new Uint8Array(arrayBuffer);

                // Create the Python byte array
                await pyodide.runPythonAsync(`
                    import js
                    from pyodide.ffi import to_js
                    
                    # Get the uint8Array from JavaScript
                    uint8Array = js.uint8Array
                    
                    # Convert to string
                    content = "".join(chr(x) for x in uint8Array)
                    
                    # Process the content
                    metadata = parse_metadata(content)
                    html_table = format_metadata_table(metadata)
                `, { uint8Array }); // Pass uint8Array as a local variable

                // Get the result back from Python
                const result = pyodide.globals.get('html_table');
                document.getElementById('output').innerHTML = result;
                
                // Clean up
                pyodide.globals.delete('uint8Array');
                pyodide.globals.delete('content');
                pyodide.globals.delete('metadata');
                pyodide.globals.delete('html_table');
            };
            
            reader.onerror = function(e) {
                console.error("FileReader error:", e);
                document.getElementById('output').innerHTML = "<p>Error reading file.</p>";
            }
            reader.readAsArrayBuffer(file);
        }
        // --- Drag and Drop Event Handlers ---
          function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation(); // Prevent the browser's default drag-and-drop behavior
            document.getElementById('drop-area').classList.add('highlight');
          }

          function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('drop-area').classList.remove('highlight');
          }

          function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('drop-area').classList.remove('highlight');

            const file = event.dataTransfer.files[0];
            if (file && file.name.match(/\.(tiff?)$/i)) { // Check file extension
                processTiff(file);
            } else {
                document.getElementById('output').innerHTML = "<p>Invalid file type. Please drop a TIFF file.</p>";
            }
          }

          // --- Event Listeners ---

          // File input (click)
          document.getElementById('fileInput').addEventListener('change', (event) => {
              const file = event.target.files[0];
              if (file) {
                  processTiff(file);
              }
          });
            // Drag and Drop events
            const dropArea = document.getElementById('drop-area');
            dropArea.addEventListener('dragover', handleDragOver);
            dropArea.addEventListener('dragleave', handleDragLeave);
            dropArea.addEventListener('drop', handleDrop);


    </script>
</body>
</html>